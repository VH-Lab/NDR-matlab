classdef TestIntanIncompleteFile < matlab.unittest.TestCase

    methods (Test)
        function testReadIncompleteFile(testCase)
            % testReadIncompleteFile - Test reading an Intan RHD file with incomplete data blocks
            %
            % This test creates a dummy .rhd file with a partial data block and checks if
            % ndr.format.intan.read_Intan_RHD2000_datafile handles it gracefully (ignoring the partial block).

            % Create a dummy header
            sample_rate = 20000;
            num_samples_per_data_block = 60;

            header = struct();
            header.fileinfo = struct(...
                'dirname', '.', ...
                'filename', 'test_incomplete_file',...
                'filesize', 0, ... % will be updated later
                'magic_number', hex2dec('c6912702'),...
                'data_file_main_version_number', 1,...
                'data_file_secondary_version_number', 2,...
                'eval_board_mode',0,...
                'reference_channel','',...
                'num_samples_per_data_block',num_samples_per_data_block,...
                'notes',struct('note1','','note2','','note3',''));
            header.fileinfo.headersize = 100;

            header.frequency_parameters = struct( ...
                'amplifier_sample_rate', sample_rate, ...
                'aux_input_sample_rate', sample_rate / 4, ...
                'supply_voltage_sample_rate', sample_rate / num_samples_per_data_block, ...
                'board_adc_sample_rate', sample_rate, ...
                'board_dig_in_sample_rate', sample_rate, ...
                'desired_dsp_cutoff_frequency', 0, ...
                'actual_dsp_cutoff_frequency', 0, ...
                'dsp_enabled', 0, ...
                'desired_lower_bandwidth', 0, ...
                'actual_lower_bandwidth', 0, ...
                'desired_upper_bandwidth', 0, ...
                'actual_upper_bandwidth', 0, ...
                'notch_filter_frequency', 0, ...
                'desired_impedance_test_frequency', 0, ...
                'actual_impedance_test_frequency', 0 );

            % Define data structure for data channels.
            channel_struct = struct( ...
                'native_channel_name', 'dummy', ...
                'custom_channel_name', 'dummy', ...
                'native_order', 0, ...
                'custom_order', 0, ...
                'board_stream', 0, ...
                'chip_channel', 0, ...
                'port_name', 'dummy', ...
                'port_prefix', 'dummy', ...
                'port_number', 0, ...
                'electrode_impedance_magnitude', 0, ...
                'electrode_impedance_phase', 0 );

            empty_channel_struct = struct( ...
                'native_channel_name', {}, ...
                'custom_channel_name', {}, ...
                'native_order', {}, ...
                'custom_order', {}, ...
                'board_stream', {}, ...
                'chip_channel', {}, ...
                'port_name', {}, ...
                'port_prefix', {}, ...
                'port_number', {}, ...
                'electrode_impedance_magnitude', {}, ...
                'electrode_impedance_phase', {} );


            header.amplifier_channels = channel_struct;
            header.amplifier_channels.native_channel_name = 'A-000';
            header.aux_input_channels = empty_channel_struct;
            header.supply_voltage_channels = empty_channel_struct;
            header.board_adc_channels = channel_struct;
            header.board_adc_channels.native_channel_name = 'ANALOG-IN-00';
            header.board_dig_in_channels = empty_channel_struct;
            header.board_dig_out_channels = empty_channel_struct;
            header.num_temp_sensor_channels = 0;


            % Create a dummy file
            filename = [tempname '.rhd'];

            % Ensure cleanup on failure
            cleanupObj = onCleanup(@() delete(filename));

            fid = fopen(filename, 'w');
            testCase.assertNotEqual(fid, -1, 'Could not open test file.');

            fwrite(fid, zeros(1, header.fileinfo.headersize), 'uint8');

            % Calculate bytes per block
            % Intan_RHD2000_blockinfo requires filename, but mostly uses header logic or reads file if header incomplete?
            % We'll assume it works as in the original script.
            [~, bytes_per_block] = ndr.format.intan.Intan_RHD2000_blockinfo(filename, header);

            % Write one and a half blocks of data
            dummy_data = zeros(1, floor(bytes_per_block * 1.5), 'uint8');
            fwrite(fid, dummy_data, 'uint8');

            fclose(fid);

            s = dir(filename);
            header.fileinfo.filesize = s.bytes;

            % 2. Call ndr.format.intan.read_Intan_RHD2000_datafile to read the file.
            % We expect it to succeed without error.

            [data,total_samples,total_time,blockinfo] = ndr.format.intan.read_Intan_RHD2000_datafile(filename, header, 'adc', 1, 0, inf);

            % 3. Verify results
            testCase.verifyEqual(total_samples, 60, 'total_samples should be 60 (1 complete block).');

            % If total_samples is correct, we can assume it handled the incomplete block correctly.
        end
    end
end
