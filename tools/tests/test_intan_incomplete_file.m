% Test script for reading incomplete Intan RHD2000 files

% 1. Create a dummy .rhd file with a partial data block.

% Create a dummy header
header = struct();
header.fileinfo.headersize = 100;
header.fileinfo.filesize = 2048;

sample_rate = 20000;
num_samples_per_data_block = 60;

header.frequency_parameters = struct( ...
	'amplifier_sample_rate', sample_rate, ...
	'aux_input_sample_rate', sample_rate / 4, ...
	'supply_voltage_sample_rate', sample_rate / num_samples_per_data_block, ...
	'board_adc_sample_rate', sample_rate, ...
	'board_dig_in_sample_rate', sample_rate, ...
	'desired_dsp_cutoff_frequency', 0, ...
	'actual_dsp_cutoff_frequency', 0, ...
	'dsp_enabled', 0, ...
	'desired_lower_bandwidth', 0, ...
	'actual_lower_bandwidth', 0, ...
	'desired_upper_bandwidth', 0, ...
	'actual_upper_bandwidth', 0, ...
	'notch_filter_frequency', 0, ...
	'desired_impedance_test_frequency', 0, ...
	'actual_impedance_test_frequency', 0 );

% Define data structure for data channels.
channel_struct = struct( ...
	'native_channel_name', 'dummy', ...
	'custom_channel_name', 'dummy', ...
	'native_order', 0, ...
	'custom_order', 0, ...
	'board_stream', 0, ...
	'chip_channel', 0, ...
	'port_name', 'dummy', ...
	'port_prefix', 'dummy', ...
	'port_number', 0, ...
	'electrode_impedance_magnitude', 0, ...
	'electrode_impedance_phase', 0 );

empty_channel_struct = struct( ...
	'native_channel_name', {}, ...
	'custom_channel_name', {}, ...
	'native_order', {}, ...
	'custom_order', {}, ...
	'board_stream', {}, ...
	'chip_channel', {}, ...
	'port_name', {}, ...
	'port_prefix', {}, ...
	'port_number', {}, ...
	'electrode_impedance_magnitude', {}, ...
	'electrode_impedance_phase', {} );


header.amplifier_channels = channel_struct;
header.amplifier_channels.native_channel_name = 'A-000';
header.aux_input_channels = empty_channel_struct;
header.supply_voltage_channels = empty_channel_struct;
header.board_adc_channels = channel_struct;
header.board_adc_channels.native_channel_name = 'ANALOG-IN-00';
header.board_dig_in_channels = empty_channel_struct;
header.board_dig_out_channels = empty_channel_struct;
header.num_temp_sensor_channels = 0;
header.fileinfo.eval_board_mode = 0;
header.fileinfo.data_file_main_version_number = 1;
header.fileinfo.data_file_secondary_version_number = 2;


% Create a dummy file
filename = 'test_incomplete_file.rhd';
fid = fopen(filename, 'w');
fwrite(fid, zeros(1, header.fileinfo.headersize), 'uint8');

% Calculate bytes per block
[~, bytes_per_block] = ndr.format.intan.Intan_RHD2000_blockinfo(filename, header);


% Write one and a half blocks of data
dummy_data = zeros(1, floor(bytes_per_block * 1.5), 'uint8');
fwrite(fid, dummy_data, 'uint8');
fclose(fid);

header.fileinfo.filesize = ftell(fopen(filename,'r'));
frewind(fopen(filename,'r'));

% 2. Call ndr.format.intan.read_Intan_RHD2000_datafile to read the file.
disp('Testing with incomplete file...');
try
    [data,total_samples,total_time,blockinfo] = ndr.format.intan.read_Intan_RHD2000_datafile(filename, header, 'adc', 1, 0, inf);

    % 3. Verify that a warning is issued and that the function returns the correct number of complete data blocks without error.
    disp('Test passed: The function executed without error.');

    if total_samples == 60
        disp('Test passed: total_samples is correct.');
    else
        disp('Test failed: total_samples is incorrect.');
    end

catch e
    disp('Test failed: An error occurred.');
    disp(e);
end

% clean up
delete(filename);
